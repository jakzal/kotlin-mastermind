package mastermind.journal

import arrow.core.left
import arrow.core.nonEmptyListOf
import arrow.core.raise.either
import kotlinx.coroutines.test.runTest
import mastermind.journal.JournalFailure.EventStoreFailure
import mastermind.journal.JournalFailure.EventStoreFailure.VersionConflict
import mastermind.journal.Stream.LoadedStream
import mastermind.journal.UpdateStreamExamples.TestEvent.Event1
import mastermind.journal.UpdateStreamExamples.TestEvent.Event2
import mastermind.testkit.assertions.shouldBe
import mastermind.testkit.assertions.shouldBeFailureOf
import mastermind.testkit.assertions.shouldFailWith
import mastermind.testkit.assertions.shouldSucceedWith
import org.junit.jupiter.api.Test

class UpdateStreamExamples {
    private val eventStore: EventStore<TestEvent, TestFailure> = InMemoryEventStore()
    private val updateStream = with(eventStore) { createUpdateStream() }
    private val streamName = UniqueSequence { index -> "stream:$index" }()

    @Test
    fun `it executes the handler on an empty stream if it is new`() = runTest {
        updateStream(streamName) {
            this shouldBe emptyStream(streamName)
            append(Event1("A1"))
        } shouldSucceedWith loadedStream(streamName, Event1("A1"))
    }

    @Test
    fun `it executes the handler on an existing stream`() = runTest {
        eventStore.append(updatedStream(streamName, Event1("A1"), Event2("A2", "Event two.")))

        updateStream(streamName) {
            this shouldBe loadedStream(streamName, Event1("A1"), Event2("A2", "Event two."))
            append(Event1("B1"))
        } shouldSucceedWith loadedStream(streamName, Event1("A1"), Event2("A2", "Event two."), Event1("B1"))
    }

    @Test
    fun `it appends events generated by the handler to the stream`() = runTest {
        eventStore.append(updatedStream(streamName, Event1("A1")))

        updateStream(streamName) {
            append(Event1("B1"))
        }

        eventStore.load(streamName) shouldSucceedWith loadedStream(streamName, Event1("A1"), Event1("B1"))
    }

    @Test
    fun `it returns the execution failure if stream update returns an error`() = runTest {
        val result = updateStream(streamName) {
            TestFailure("Command failed.").left()
        }

        result shouldBeFailureOf JournalFailure.ExecutionFailure(TestFailure("Command failed."))
    }


    @Test
    fun `it returns the eventstore failure if the event store fails to append events`() = runTest {
        val events = nonEmptyListOf(Event1("A1"))
        val eventStore: EventStore<TestEvent, TestFailure> = object : EventStore<TestEvent, TestFailure> {
            override suspend fun load(streamName: StreamName) =
                either<EventStoreFailure<TestFailure>, LoadedStream<TestEvent>> {
                    loadedStream(streamName, events)
                }

            override suspend fun append(stream: Stream.UpdatedStream<TestEvent>) =
                VersionConflict<TestFailure>(streamName, 1, 2).left()

        }
        val updateStream = with(eventStore) { createUpdateStream() }

        updateStream(streamName) {
            append(Event1("B1"))
        } shouldFailWith VersionConflict(streamName, 1, 2)
    }

    @Test
    fun `it returns the eventstore failure if the event store fails to load events`() = runTest {
        val eventStore: EventStore<TestEvent, TestFailure> = object : EventStore<TestEvent, TestFailure> {
            override suspend fun load(streamName: StreamName) =
                VersionConflict<TestFailure>(streamName, 1, 2).left()

            override suspend fun append(stream: Stream.UpdatedStream<TestEvent>) =
                throw RuntimeException("Unexpected call to append events.")

        }
        val updateStream = with(eventStore) { createUpdateStream() }

        updateStream(streamName) {
            append(Event1("B1"))
        } shouldFailWith VersionConflict(streamName, 1, 2)
    }

    private sealed interface TestEvent {
        val id: String

        data class Event1(override val id: String) : TestEvent
        data class Event2(override val id: String, val name: String) : TestEvent
    }

    private data class TestFailure(val cause: String)
}