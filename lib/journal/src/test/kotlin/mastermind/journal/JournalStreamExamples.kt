package mastermind.journal

import arrow.core.left
import arrow.core.nonEmptyListOf
import arrow.core.raise.either
import kotlinx.coroutines.test.runTest
import mastermind.journal.JournalFailure.*
import mastermind.journal.JournalStreamExamples.TestEvent.Event1
import mastermind.journal.JournalStreamExamples.TestEvent.Event2
import mastermind.journal.Stream.LoadedStream
import mastermind.journal.Stream.UpdatedStream
import mastermind.testkit.assertions.shouldBe
import mastermind.testkit.assertions.shouldBeFailureOf
import mastermind.testkit.assertions.shouldFailWith
import mastermind.testkit.assertions.shouldSucceedWith
import org.junit.jupiter.api.Test

class JournalStreamExamples {
    private val journal: Journal<TestEvent, TestFailure> = InMemoryJournal()
    private val updateStream = with(journal) { createUpdateStream() }
    private val loadStream = with(journal) { createLoadStream() }
    private val streamName = UniqueSequence { index -> "stream:$index" }()

    @Test
    fun `it executes the handler on an empty stream if it is new`() = runTest {
        updateStream(streamName) {
            this shouldBe emptyStream(streamName)
            append(Event1("A1"))
        } shouldSucceedWith loadedStream(streamName, Event1("A1"))
    }

    @Test
    fun `it executes the handler on an existing stream`() = runTest {
        journal.append(updatedStream(streamName, Event1("A1"), Event2("A2", "Event two.")))

        updateStream(streamName) {
            this shouldBe loadedStream(streamName, Event1("A1"), Event2("A2", "Event two."))
            append(Event1("B1"))
        } shouldSucceedWith loadedStream(streamName, Event1("A1"), Event2("A2", "Event two."), Event1("B1"))
    }

    @Test
    fun `it appends events generated by the handler to the stream`() = runTest {
        journal.append(updatedStream(streamName, Event1("A1")))

        updateStream(streamName) {
            append(Event1("B1"))
        }

        journal.load(streamName) shouldSucceedWith loadedStream(streamName, Event1("A1"), Event1("B1"))
    }

    @Test
    fun `it returns the execution failure if stream update returns an error`() = runTest {
        val result = updateStream(streamName) {
            TestFailure("Command failed.").left()
        }

        result shouldBeFailureOf ExecutionFailure(TestFailure("Command failed."))
    }


    @Test
    fun `it returns the eventstore failure if the event store fails to append events`() = runTest {
        val events = nonEmptyListOf(Event1("A1"))
        val journal: Journal<TestEvent, TestFailure> = object : Journal<TestEvent, TestFailure> {
            override suspend fun load(streamName: StreamName) =
                either<JournalFailure<TestFailure>, LoadedStream<TestEvent>> {
                    loadedStream(streamName, events)
                }

            override suspend fun append(stream: UpdatedStream<TestEvent>) =
                VersionConflict<TestFailure>(streamName, 1, 2).left()

        }
        val updateStream = with(journal) { createUpdateStream() }

        updateStream(streamName) {
            append(Event1("B1"))
        } shouldFailWith VersionConflict(streamName, 1, 2)
    }

    @Test
    fun `it returns the eventstore failure if the event store fails to load events`() = runTest {
        val journal: Journal<TestEvent, TestFailure> = object : Journal<TestEvent, TestFailure> {
            override suspend fun load(streamName: StreamName) =
                VersionConflict<TestFailure>(streamName, 1, 2).left()

            override suspend fun append(stream: UpdatedStream<TestEvent>) =
                throw RuntimeException("Unexpected call to append events.")

        }
        val updateStream = with(journal) { createUpdateStream() }

        updateStream(streamName) {
            append(Event1("B1"))
        } shouldFailWith VersionConflict(streamName, 1, 2)
    }

    @Test
    fun `it loads a stream from the event store`() = runTest {
        journal.append(updatedStream(streamName, Event1("A1"), Event2("A2", "Event two.")))

        loadStream(streamName) shouldSucceedWith loadedStream(
            streamName,
            Event1("A1"),
            Event2("A2", "Event two.")
        )
    }

    @Test
    fun `it returns an error if the stream is not found in the event store`() = runTest {
        loadStream(streamName) shouldFailWith StreamNotFound(streamName)
    }

    private sealed interface TestEvent {
        val id: String

        data class Event1(override val id: String) : TestEvent
        data class Event2(override val id: String, val name: String) : TestEvent
    }

    private data class TestFailure(val cause: String)
}